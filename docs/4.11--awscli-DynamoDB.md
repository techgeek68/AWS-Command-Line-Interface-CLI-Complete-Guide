# AWS CLI — DynamoDB Operations Guide

---
> Replace sample names (tables, keys, ARNs, regions, account, etc.) with your own.
---

Sections:
1. Overview  
2. Quick Reference Variables  
3. Table Operations (Create / Describe / Update / Delete)  
4. Advanced Table Features (GSI, LSI, TTL, Streams, PITR)  
5. Capacity Modes & Scaling  
6. Import / Export / Backup / Restore  
7. Global Tables (Multi-Region)  
8. Item Operations (Put / Get / Update / Delete)  
9. Batch Operations (BatchWrite / BatchGet)  
10. Query (Key & Filter Expressions)  
11. Scan & Pagination  
12. Expressions (Update / Condition / Projection)  
13. Transactions (TransactWrite / TransactGet)  
14. PartiQL Examples  
15. Streams (Describe / Shards / Get Records)  
16. Metrics (CloudWatch)  
17. Tagging  
18. Best Practices  
19. Troubleshooting  
20. Automation Snippets  
21. Cleanup Sequences  
22. Notes  

---

## 1. Overview
Amazon DynamoDB is a fully managed NoSQL key-value & document database. Core pieces:
- Primary Key: Partition (hash) key alone or composite (partition + sort key).
- Capacity: On-demand (PAY_PER_REQUEST) or provisioned (RCU/WCU).
- GSIs & LSIs: Secondary indexes (GSI: partition & optional sort; LSI: alternate sort key, same partition key).
- TTL: Automatic expiration of items via an epoch attribute.
- Streams: Change data capture (insert/modify/remove).
- Transactions: ACID across up to 25 items / 4 MB.
- Global Tables: Multi-region replication.
- Backups: On-demand and Point-In-Time Recovery (PITR).

---

## 2. Quick Reference Variables
```bash
export TABLE_NAME=Orders
export PK_NAME=OrderId
export SK_NAME=CreatedAt
export REGION=us-east-1
export ACCOUNT_ID=123456789012
export GSI_NAME=StatusIndex
export GSI_PK=Status
export TTL_ATTR=ExpiresAt
```

---

## 3. Table Operations

### 3.1 List tables
Syntax:
```bash
aws dynamodb list-tables --query 'TableNames[]'
```
Example:
```bash
aws dynamodb list-tables --query 'TableNames[]' --output table
```

### 3.2 Create table (simple, on-demand)
Syntax:
```bash
aws dynamodb create-table \
  --table-name <TABLE_NAME> \
  --attribute-definitions AttributeName=<PARTITION_KEY>,AttributeType=<S|N|B> \
  --key-schema AttributeName=<PARTITION_KEY>,KeyType=HASH \
  --billing-mode PAY_PER_REQUEST
```
Example:
```bash
aws dynamodb create-table \
  --table-name Orders \
  --attribute-definitions AttributeName=OrderId,AttributeType=S \
  --key-schema AttributeName=OrderId,KeyType=HASH \
  --billing-mode PAY_PER_REQUEST
```

### 3.3 Create table (composite key, provisioned capacity)
Example:
```bash
aws dynamodb create-table \
  --table-name Orders \
  --attribute-definitions \
      AttributeName=OrderId,AttributeType=S \
      AttributeName=CreatedAt,AttributeType=S \
  --key-schema \
      AttributeName=OrderId,KeyType=HASH \
      AttributeName=CreatedAt,KeyType=RANGE \
  --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5
```

### 3.4 Describe table
Syntax:
```bash
aws dynamodb describe-table --table-name <TABLE_NAME>
```
Example (select basics):
```bash
aws dynamodb describe-table --table-name Orders \
  --query 'Table.{Name:TableName,Status:TableStatus,ItemCount:ItemCount,SizeBytes:TableSizeBytes}'
```

### 3.5 Update provisioned throughput
Syntax:
```bash
aws dynamodb update-table \
  --table-name <TABLE_NAME> \
  --provisioned-throughput ReadCapacityUnits=<RCU>,WriteCapacityUnits=<WCU>
```
Example:
```bash
aws dynamodb update-table \
  --table-name Orders \
  --provisioned-throughput ReadCapacityUnits=10,WriteCapacityUnits=10
```

### 3.6 Delete table
Syntax:
```bash
aws dynamodb delete-table --table-name <TABLE_NAME>
```
Example:
```bash
aws dynamodb delete-table --table-name Orders
```

### 3.7 Wait for table active
```bash
aws dynamodb wait table-exists --table-name Orders
```

---

## 4. Advanced Table Features

### 4.1 Add GSI (Global Secondary Index)
GSI requires attribute definition for its key(s).
Example (add StatusIndex on Status attribute):
```bash
aws dynamodb update-table \
  --table-name Orders \
  --attribute-definitions AttributeName=Status,AttributeType=S \
  --global-secondary-index-updates \
      '[{"Create":{"IndexName":"StatusIndex","KeySchema":[{"AttributeName":"Status","KeyType":"HASH"}],"Projection":{"ProjectionType":"ALL"},"ProvisionedThroughput":{"ReadCapacityUnits":5,"WriteCapacityUnits":5}}}]'
```

### 4.2 Delete GSI
```bash
aws dynamodb update-table \
  --table-name Orders \
  --global-secondary-index-updates '[{"Delete":{"IndexName":"StatusIndex"}}]'
```

### 4.3 Create table w/ LSI (must define at create time)
Example:
```bash
aws dynamodb create-table \
  --table-name Orders \
  --attribute-definitions \
      AttributeName=OrderId,AttributeType=S \
      AttributeName=CreatedAt,AttributeType=S \
      AttributeName=Status,AttributeType=S \
  --key-schema \
      AttributeName=OrderId,KeyType=HASH \
      AttributeName=CreatedAt,KeyType=RANGE \
  --local-secondary-indexes \
      '[
        {
          "IndexName": "StatusLSI",
          "KeySchema": [
            {"AttributeName":"OrderId","KeyType":"HASH"},
            {"AttributeName":"Status","KeyType":"RANGE"}
          ],
          "Projection": {"ProjectionType":"ALL"}
        }
      ]' \
  --billing-mode PAY_PER_REQUEST
```

### 4.4 Enable TTL
Syntax:
```bash
aws dynamodb update-time-to-live \
  --table-name <TABLE_NAME> \
  --time-to-live-specification "Enabled=true,AttributeName=<TTL_ATTRIBUTE>"
```
Example:
```bash
aws dynamodb update-time-to-live \
  --table-name Orders \
  --time-to-live-specification "Enabled=true,AttributeName=ExpiresAt"
```

### 4.5 Enable Streams (when creating or via update)
Example (update to NEW_AND_OLD_IMAGES):
```bash
aws dynamodb update-table \
  --table-name Orders \
  --stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```

### 4.6 Enable Point-In-Time Recovery (PITR)
```bash
aws dynamodb update-continuous-backups \
  --table-name Orders \
  --point-in-time-recovery-specification PointInTimeRecoveryEnabled=true
```

---

## 5. Capacity Modes & Scaling

### 5.1 Switch to on-demand (PAY_PER_REQUEST)
```bash
aws dynamodb update-table \
  --table-name Orders \
  --billing-mode PAY_PER_REQUEST
```

### 5.2 Switch to provisioned (with RCUs/WCUs)
```bash
aws dynamodb update-table \
  --table-name Orders \
  --billing-mode PROVISIONED \
  --provisioned-throughput ReadCapacityUnits=20,WriteCapacityUnits=10
```

### 5.3 Auto scaling (uses Application Auto Scaling—example register target)
(High-level snippet)
```bash
aws application-autoscaling register-scalable-target \
  --service-namespace dynamodb \
  --resource-id table/Orders \
  --scalable-dimension dynamodb:table:WriteCapacityUnits \
  --min-capacity 5 --max-capacity 100
```

---

## 6. Import / Export / Backup / Restore

### 6.1 On-demand backup
```bash
aws dynamodb create-backup \
  --table-name Orders \
  --backup-name Orders-backup-$(date +%Y%m%d)
```

### 6.2 List backups
```bash
aws dynamodb list-backups --table-name Orders --query 'BackupSummaries[].{Name:BackupName,Status:BackupStatus}'
```

### 6.3 Restore table to new name
```bash
aws dynamodb restore-table-from-backup \
  --target-table-name Orders-Restore \
  --backup-arn arn:aws:dynamodb:us-east-1:$ACCOUNT_ID:table/Orders/backup/016c3example
```

### 6.4 Export table to S3 (point in time)
```bash
aws dynamodb export-table-to-point-in-time \
  --table-arn arn:aws:dynamodb:us-east-1:$ACCOUNT_ID:table/Orders \
  --s3-bucket dynamodb-exports-dev \
  --export-format DYNAMODB_JSON
```

### 6.5 Import from S3 to new table (JSON)
```bash
aws dynamodb import-table \
  --input-format DYNAMODB_JSON \
  --input-compression-type NONE \
  --s3-bucket-source S3Bucket=dynamodb-exports-dev,S3KeyPrefix=exports/orders/ \
  --table-creation-parameters '{
    "TableName":"OrdersImported",
    "AttributeDefinitions":[{"AttributeName":"OrderId","AttributeType":"S"}],
    "KeySchema":[{"AttributeName":"OrderId","KeyType":"HASH"}],
    "BillingMode":"PAY_PER_REQUEST"
  }'
```

---

## 7. Global Tables (v2019.11.21 style)

### 7.1 Create in one region then add replication
(Assuming table already created with identical schema.)
```bash
aws dynamodb update-table \
  --table-name Orders \
  --replica-updates '[{"Create":{"RegionName":"us-west-2"}}]'
```

### 7.2 Describe replicas
```bash
aws dynamodb describe-table --table-name Orders \
  --query 'Table.Replicas[].{Region:RegionName,Status:ReplicaStatus}'
```

### 7.3 Remove replica
```bash
aws dynamodb update-table \
  --table-name Orders \
  --replica-updates '[{"Delete":{"RegionName":"us-west-2"}}]'
```

---

## 8. Item Operations

### 8.1 Put item (simple)
Syntax:
```bash
aws dynamodb put-item --table-name <TABLE> --item '{"<PK>":{"S":"<VALUE>"}}'
```
Example:
```bash
aws dynamodb put-item \
  --table-name Orders \
  --item '{"OrderId":{"S":"O10001"},"CreatedAt":{"S":"2025-08-28T04:05:00Z"},"Status":{"S":"PENDING"},"Amount":{"N":"59.99"}}'
```

### 8.2 Conditional put (only if not exists)
```bash
aws dynamodb put-item \
  --table-name Orders \
  --item '{"OrderId":{"S":"O10002"},"CreatedAt":{"S":"2025-08-28T04:06:00Z"},"Status":{"S":"PENDING"}}' \
  --condition-expression "attribute_not_exists(OrderId)"
```

### 8.3 Get item
Syntax:
```bash
aws dynamodb get-item --table-name <TABLE> --key '{"<PK>":{"S":"<VALUE>"}}'
```
Example:
```bash
aws dynamodb get-item \
  --table-name Orders \
  --key '{"OrderId":{"S":"O10001"}}' \
  --consistent-read
```

### 8.4 Delete item
```bash
aws dynamodb delete-item \
  --table-name Orders \
  --key '{"OrderId":{"S":"O10001"}}'
```

### 8.5 Update item (expression)
Syntax:
```bash
aws dynamodb update-item \
  --table-name <TABLE> \
  --key '{"<PK>":{"S":"<VALUE>"}}' \
  --update-expression "SET <Attr>=:val" \
  --expression-attribute-values '{":val":{"S":"<NEW>"}}'
```
Example:
```bash
aws dynamodb update-item \
  --table-name Orders \
  --key '{"OrderId":{"S":"O10002"}}' \
  --update-expression "SET Status = :s, Amount = :a" \
  --expression-attribute-values '{":s":{"S":"SHIPPED"},":a":{"N":"59.99"}}' \
  --return-values UPDATED_NEW
```

---

## 9. Batch Operations

### 9.1 Batch write (Put + Delete)
Create file `batch-write.json`:
```json
{
  "Orders": [
    {
      "PutRequest": {
        "Item": {
          "OrderId": {"S":"O10010"},
          "CreatedAt":{"S":"2025-08-28T04:10:00Z"},
          "Status":{"S":"PENDING"}
        }
      }
    },
    {
      "DeleteRequest": {
        "Key": {"OrderId": {"S":"O10001"}}
      }
    }
  ]
}
```
Execute:
```bash
aws dynamodb batch-write-item --request-items file://batch-write.json
```

### 9.2 Batch get
Create `batch-get.json`:
```json
{
  "Orders": {
    "Keys": [
      {"OrderId":{"S":"O10002"}},
      {"OrderId":{"S":"O10010"}}
    ],
    "ConsistentRead": false
  }
}
```
Run:
```bash
aws dynamodb batch-get-item --request-items file://batch-get.json
```

---

## 10. Query

### 10.1 Query by partition key (simple)
Syntax:
```bash
aws dynamodb query --table-name <TABLE> \
  --key-condition-expression "<PK> = :v1" \
  --expression-attribute-values '{":v1":{"S":"<PK_VALUE>"}}'
```
Example:
```bash
aws dynamodb query \
  --table-name Orders \
  --key-condition-expression "OrderId = :id" \
  --expression-attribute-values '{":id":{"S":"O10002"}}'
```

### 10.2 Query on composite key with sort key condition
Example:
```bash
aws dynamodb query \
  --table-name Orders \
  --key-condition-expression "OrderId = :id AND CreatedAt BETWEEN :start AND :end" \
  --expression-attribute-values '{
    ":id":{"S":"O10002"},
    ":start":{"S":"2025-08-28T00:00:00Z"},
    ":end":{"S":"2025-08-28T23:59:59Z"}
  }'
```

### 10.3 Query GSI
```bash
aws dynamodb query \
  --table-name Orders \
  --index-name StatusIndex \
  --key-condition-expression "Status = :s" \
  --expression-attribute-values '{":s":{"S":"PENDING"}}'
```

### 10.4 Query with filter (NOTE: filter runs after key condition)
```bash
aws dynamodb query \
  --table-name Orders \
  --index-name StatusIndex \
  --key-condition-expression "Status = :s" \
  --filter-expression "Amount > :min" \
  --expression-attribute-values '{":s":{"S":"PENDING"},":min":{"N":"50"}}'
```

---

## 11. Scan & Pagination

### 11.1 Basic scan (limit items)
Syntax:
```bash
aws dynamodb scan --table-name <TABLE> --max-items <N>
```
Example:
```bash
aws dynamodb scan --table-name Orders --max-items 25
```

### 11.2 Paginated scan (loop with LastEvaluatedKey)
Example shell snippet:
```bash
EX ExclusiveStartKey=""; 
while :; do
  RESP=$(aws dynamodb scan --table-name Orders --max-items 10 ${EX})
  echo "$RESP" | jq '.Items[].OrderId.S'
  LEK=$(echo "$RESP" | jq -r '.NextToken // empty')
  [ -z "$LEK" ] && break
  EX="--starting-token $LEK"
done
```

### 11.3 Filtered scan (avoid when possible)
```bash
aws dynamodb scan \
  --table-name Orders \
  --filter-expression "contains(Status,:s)" \
  --expression-attribute-values '{":s":{"S":"PEND"}}'
```

---

## 12. Expressions

### 12.1 Update expression with list append
```bash
aws dynamodb update-item \
  --table-name Orders \
  --key '{"OrderId":{"S":"O10002"}}' \
  --update-expression "SET Notes = list_append(if_not_exists(Notes, :empty), :n)" \
  --expression-attribute-values '{
    ":empty":{"L":[]},
    ":n":{"L":[{"S":"Packed"},{"S":"LabelPrinted"}]}
  }'
```

### 12.2 Condition expression (prevent overwrite)
```bash
aws dynamodb put-item \
  --table-name Orders \
  --item '{"OrderId":{"S":"O10002"},"Status":{"S":"NEW"}}' \
  --condition-expression "attribute_not_exists(OrderId)"
```

### 12.3 Projection expression (return partial attributes)
```bash
aws dynamodb get-item \
  --table-name Orders \
  --key '{"OrderId":{"S":"O10002"}}' \
  --projection-expression "OrderId, Status"
```

---

## 13. Transactions

### 13.1 TransactWriteItems (Put + Update)
File `transact-write.json`:
```json
{
  "TransactItems": [
    {
      "Put": {
        "TableName": "Orders",
        "Item": {
          "OrderId": { "S": "O20001" },
          "CreatedAt": { "S": "2025-08-28T04:20:00Z" },
          "Status": { "S": "PENDING" }
        },
        "ConditionExpression": "attribute_not_exists(OrderId)"
      }
    },
    {
      "Update": {
        "TableName": "Orders",
        "Key": { "OrderId": { "S": "O10002" } },
        "UpdateExpression": "SET Status = :s",
        "ExpressionAttributeValues": { ":s": { "S": "FULFILLED" } }
      }
    }
  ]
}
```
Execute:
```bash
aws dynamodb transact-write-items --transact-items file://transact-write.json
```

### 13.2 TransactGetItems
File `transact-get.json`:
```json
{
  "TransactItems": [
    { "Get": { "TableName":"Orders","Key":{"OrderId":{"S":"O10002"}} } },
    { "Get": { "TableName":"Orders","Key":{"OrderId":{"S":"O20001"}} } }
  ]
}
```
Run:
```bash
aws dynamodb transact-get-items --transact-items file://transact-get.json
```

---

## 14. PartiQL Examples

### 14.1 Insert
```bash
aws dynamodb execute-statement \
  --statement "INSERT INTO Orders VALUE {'OrderId':'O30001','CreatedAt':'2025-08-28T04:25:00Z','Status':'PENDING','Amount':42.50}"
```

### 14.2 Select with parameter placeholder
```bash
aws dynamodb execute-statement \
  --statement "SELECT OrderId, Status FROM Orders WHERE OrderId=?" \
  --parameters '{"S":"O30001"}'
```

### 14.3 Update
```bash
aws dynamodb execute-statement \
  --statement "UPDATE Orders SET Status='CANCELLED' WHERE OrderId='O30001'"
```

### 14.4 Delete
```bash
aws dynamodb execute-statement \
  --statement "DELETE FROM Orders WHERE OrderId='O30001'"
```

---

## 15. Streams

### 15.1 Describe stream ARN (from table)
```bash
aws dynamodb describe-table --table-name Orders \
  --query 'Table.LatestStreamArn'
```

### 15.2 Describe stream (list shards)
```bash
STREAM_ARN=$(aws dynamodb describe-table --table-name Orders --query 'Table.LatestStreamArn' --output text)
aws dynamodbstreams describe-stream \
  --stream-arn $STREAM_ARN \
  --query 'StreamDescription.Shards[].ShardId'
```

### 15.3 Get shard iterator & records (low-level example)
```bash
SHARD_ID=$(aws dynamodbstreams describe-stream --stream-arn $STREAM_ARN \
  --query 'StreamDescription.Shards[0].ShardId' --output text)

ITR=$(aws dynamodbstreams get-shard-iterator \
  --stream-arn $STREAM_ARN \
  --shard-id $SHARD_ID \
  --shard-iterator-type TRIM_HORIZON \
  --query 'ShardIterator' --output text)

aws dynamodbstreams get-records --shard-iterator $ITR
```

---

## 16. Metrics (CloudWatch)

### 16.1 Consumed read capacity units (last 15m)
```bash
aws cloudwatch get-metric-statistics \
  --namespace AWS/DynamoDB \
  --metric-name ConsumedReadCapacityUnits \
  --dimensions Name=TableName,Value=Orders \
  --start-time "$(date -u -d '15 minutes ago' +%FT%TZ)" \
  --end-time "$(date -u +%FT%TZ)" \
  --period 60 \
  --statistics Sum \
  --query 'Datapoints|sort_by(@,&Timestamp)[].{T:Timestamp,Sum:Sum}'
```

### 16.2 Throttled requests
```bash
aws cloudwatch get-metric-statistics \
  --namespace AWS/DynamoDB \
  --metric-name ThrottledRequests \
  --dimensions Name=TableName,Value=Orders \
  --start-time "$(date -u -d '30 minutes ago' +%FT%TZ)" \
  --end-time "$(date -u +%FT%TZ)" \
  --period 300 \
  --statistics Sum
```

---

## 17. Tagging

### 17.1 List tags
```bash
TABLE_ARN=$(aws dynamodb describe-table --table-name Orders --query 'Table.TableArn' --output text)
aws dynamodb list-tags-of-resource --resource-arn $TABLE_ARN
```

### 17.2 Tag resource
```bash
aws dynamodb tag-resource \
  --resource-arn $TABLE_ARN \
  --tags Key=Env,Value=dev Key=Project,Value=ECommerce
```

### 17.3 Untag resource
```bash
aws dynamodb untag-resource \
  --resource-arn $TABLE_ARN \
  --tag-keys Env
```

---

## 18. Best Practices
- Model *access patterns first*, not relational schemas.
- Keep item size small; use S3 for large blobs (store object key).
- Prefer composite keys + sorted queries instead of scans.
- Avoid hot partitions: distribute partition key values; add random suffix when necessary.
- Use GSIs sparingly; align their key schema to specific queries.
- Implement TTL for ephemeral data (sessions, tokens).
- Monitor `Consumed*` vs. `Provisioned*` and `ThrottledRequests`.
- Use on-demand for unpredictable workloads; switch to provisioned when stable/high-volume.
- Batch writes in groups of 25 to optimize network usage.
- Employ conditional writes to avoid lost updates (optimistic locking with a version attribute).
- Keep read/write units margin to handle bursts or adopt auto scaling.
- Export data for analytical queries instead of scanning production tables.
- Use transactions only when strictly needed (they have extra overhead).

---

## 19. Troubleshooting
| Issue | Symptom | Likely Cause | Resolution |
|-------|---------|--------------|-----------|
| ThrottledRequests > 0 | Provisioned burst errors | Insufficient capacity / hot key | Increase RCUs/WCUs, distribute keys, on-demand mode |
| ConditionalCheckFailedException | Write failed | Condition expression not met | Validate logic / existence; adjust condition |
| ProvisionedThroughputExceededException | Retries / latency | Exceeding capacity | Backoff/retry with jitter; scale capacity or on-demand |
| ValidationException | CLI command rejected | Attribute type mismatch / invalid expression | Verify JSON types & expression syntax |
| ResourceInUseException (create) | Table exists | Duplicate name | Choose new name or delete existing table |
| ResourceNotFoundException | Table/index missing | Typo or still creating | Wait for ACTIVE status; check name |
| Slow queries (over scan) | High latency & cost | Using Scan for targeted reads | Switch to Query with key design |
| TransactionCanceledException | Multi-item op failed | One or more condition failures | Inspect `CancellationReasons` (enable ReturnCancellationReasons) |
| Expired TTL items visible | Items not deleted yet | TTL asynchronous | Allow 48h; TTL not real-time deletion |
| Stream shard iterator expired | GetRecords fails | Iterator not used timely | Request new iterator and resume |

---

## 20. Automation Snippets

### 20.1 Safe create if missing
```bash
TABLE=Orders
EXISTS=$(aws dynamodb list-tables --query "contains(TableNames,'$TABLE')")
if [ "$EXISTS" = "false" ]; then
  aws dynamodb create-table \
    --table-name $TABLE \
    --attribute-definitions AttributeName=OrderId,AttributeType=S \
    --key-schema AttributeName=OrderId,KeyType=HASH \
    --billing-mode PAY_PER_REQUEST
  aws dynamodb wait table-exists --table-name $TABLE
fi
```

### 20.2 Export & wait
```bash
EXPORT_ARN=$(aws dynamodb export-table-to-point-in-time \
  --table-arn $(aws dynamodb describe-table --table-name Orders --query 'Table.TableArn' --output text) \
  --s3-bucket dynamodb-exports-dev \
  --export-format DYNAMODB_JSON \
  --query 'ExportDescription.ExportArn' --output text)

echo "Export started: $EXPORT_ARN"
```

### 20.3 Detect throttling spike (last 5 min)
```bash
aws cloudwatch get-metric-statistics \
  --namespace AWS/DynamoDB \
  --metric-name ThrottledRequests \
  --dimensions Name=TableName,Value=Orders \
  --start-time "$(date -u -d '5 minutes ago' +%FT%TZ)" \
  --end-time "$(date -u +%FT%TZ)" \
  --period 60 \
  --statistics Sum \
  --query 'Datapoints[].Sum'
```

---

## 21. Cleanup Sequences

### 21.1 Delete table and wait
```bash
aws dynamodb delete-table --table-name Orders
aws dynamodb wait table-not-exists --table-name Orders
```

### 21.2 Remove GSI (if still exists)
```bash
aws dynamodb update-table \
  --table-name Orders \
  --global-secondary-index-updates '[{"Delete":{"IndexName":"StatusIndex"}}]'
```

### 21.3 Delete on-demand backup(s) (list & delete)
```bash
aws dynamodb list-backups --table-name Orders \
  --query 'BackupSummaries[].BackupArn' --output text | tr '\t' '\n' | while read ARN; do
    aws dynamodb delete-backup --backup-arn "$ARN"
  done
```

### 21.4 Remove replica regions
```bash
aws dynamodb update-table \
  --table-name Orders \
  --replica-updates '[{"Delete":{"RegionName":"us-west-2"}}]'
```

---

## 22. Notes
- Attribute types: S (string), N (number), B (binary), plus complex (M, L, BOOL, NULL) when using item JSON.
- Size limits: Item max 400 KB. Avoid large attributes; externalize blobs.
- BatchWrite doesn’t guarantee all succeed; check UnprocessedItems and retry.
- Streams retention: 24 hours rolling window.
- PITR retains from 35 days (typical) to the earliest restore; confirm region specifics.
- GSI creation time can lag—always poll the table status until ACTIVE and index status.
- Do not overuse scans; they read entire partitions and can become cost hot spots.
- For strongly consistent reads, only on base table reads (not GSIs).
- TTL attribute must be epoch timestamp (in seconds), not milliseconds.

---
