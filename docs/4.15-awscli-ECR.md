# AWS CLI — ECR (Elastic Container Registry) Operations Guide

---
> Replace 123456789012 with your AWS Account ID and adjust region (us-east-1).
---
> Focus: Repositories, Auth, Images (Tag/Push/Pull/Scan), Lifecycle Policies, Replication, Permissions, Batch Ops, Vulnerability Scanning, Multi-Arch, Cleanup, Troubleshooting, Automation.
---

## Table of Contents
1. Overview  
2. Quick Reference Variables  
3. Repositories (Create / List / Describe / Delete)  
4. Repository Settings (Lifecycle / Scanning / Encryption / Replication)  
5. Authentication (Docker / Podman)  
6. Image Build, Tag, Push, Pull  
7. Listing & Inspecting Images  
8. Image Scanning & Vulnerability Management  
9. Permissions & Repository Policies (Cross-Account)  
10. Lifecycle Policies (Tag Retention / Expiration)  
11. Replication Configuration (Cross-Region / Cross-Account)  
12. Batch Operations (Delete / Get)  
13. Multi-Architecture Images (Buildx Manifest)  
14. Tagging Resources (Repository Tags vs Image Tags)  
15. Cost & Optimization Tips  
16. Automation Snippets  
17. Best Practices  
18. Troubleshooting  
19. Cleanup Sequences  
20. Notes  
21. Revision  

---

## 1. Overview
Amazon ECR is a managed container image registry supporting private & public repositories, vulnerability scanning (basic & enhanced), lifecycle policies, cross‑account replication, and encryption at rest (KMS).  
Typical workflow: Create repository → Authenticate Docker client → Build & tag image → Push → (Optionally) Scan → Deploy via ECS / EKS / Lambda.

---

## 2. Quick Reference Variables
```bash
export ACCOUNT_ID=123456789012
export REGION=us-east-1
export REPO_NAME=sample-api
export REPO_FQDN=$ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com
export IMAGE_TAG=v1.0.0
export BASE_TAG=latest
export OTHER_ACCOUNT=210987654321
```

---

## 3. Repositories (Create / List / Describe / Delete)

### 3.1 Create repository (private, image scanning enabled, immutable tags)
Syntax:
```bash
aws ecr create-repository \
  --repository-name <REPOSITORY_NAME> \
  [--image-scanning-configuration scanOnPush=true] \
  [--image-tag-mutability IMMUTABLE|MUTABLE] \
  [--encryption-configuration encryptionType=KMS,kmsKey=<KMS_KEY_ARN>]
```
Example:
```bash
aws ecr create-repository \
  --repository-name sample-api \
  --image-scanning-configuration scanOnPush=true \
  --image-tag-mutability IMMUTABLE
```

### 3.2 List repositories
Syntax:
```bash
aws ecr describe-repositories --query 'repositories[].repositoryName'
```
Example:
```bash
aws ecr describe-repositories \
  --query 'repositories[].{Name:repositoryName,URI:repositoryUri}'
```

### 3.3 Describe single repository
Syntax:
```bash
aws ecr describe-repositories --repository-names <REPO>
```
Example:
```bash
aws ecr describe-repositories --repository-names sample-api \
  --query 'repositories[0].{Name:repositoryName,URI:repositoryUri,ScanOnPush:imageScanningConfiguration.scanOnPush,Mutable:imageTagMutability}'
```

### 3.4 Delete repository (force = remove images)
Syntax:
```bash
aws ecr delete-repository --repository-name <REPO> --force
```
Example:
```bash
aws ecr delete-repository --repository-name sample-api --force
```

---

## 4. Repository Settings (Lifecycle / Scanning / Encryption / Replication)

### 4.1 Update tag mutability to MUTABLE
```bash
aws ecr put-image-tag-mutability \
  --repository-name sample-api \
  --image-tag-mutability MUTABLE
```

### 4.2 Set scan on push to true
```bash
aws ecr put-image-scanning-configuration \
  --repository-name sample-api \
  --image-scanning-configuration scanOnPush=true
```

### 4.3 Set encryption with customer-managed KMS key
```bash
aws ecr put-replication-configuration \
  --replication-configuration '{
    "rules":[{"destinations":[{"region":"us-west-2","registryId":"'"$ACCOUNT_ID"'"}]}]
  }'
```
(Replication config shown; encryption is per repo at create; existing encryption type cannot be changed—create new repo if needed.)

---

## 5. Authentication (Docker / Podman)

### 5.1 Login using get-login-password (recommended)
Syntax:
```bash
aws ecr get-login-password --region <REGION> | \
  docker login --username AWS --password-stdin <ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com
```
Example:
```bash
aws ecr get-login-password --region $REGION | \
  docker login --username AWS --password-stdin $REPO_FQDN
```

### 5.2 Legacy (NOT recommended) get-authorization-token
```bash
aws ecr get-authorization-token --query 'authorizationData[0].authorizationToken' --output text | base64 -d
```

---

## 6. Image Build, Tag, Push, Pull

### 6.1 Build local image
Syntax:
```bash
docker build -t <LOCAL_NAME>:<TAG> .
```
Example:
```bash
docker build -t sample-api:build .
```

### 6.2 Tag image for ECR
Syntax:
```bash
docker tag <LOCAL_IMAGE>:<LOCAL_TAG> <ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/<REPOSITORY_NAME>:<IMAGE_TAG>
```
Example:
```bash
docker tag sample-api:build $REPO_FQDN/$REPO_NAME:$IMAGE_TAG
```

### 6.3 Push image
Syntax:
```bash
docker push <ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/<REPO>:<TAG>
```
Example:
```bash
docker push $REPO_FQDN/$REPO_NAME:$IMAGE_TAG
```

### 6.4 Retag latest (if mutable)
```bash
docker tag $REPO_FQDN/$REPO_NAME:$IMAGE_TAG $REPO_FQDN/$REPO_NAME:$BASE_TAG
docker push $REPO_FQDN/$REPO_NAME:$BASE_TAG
```

### 6.5 Pull image
Syntax:
```bash
docker pull <ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/<REPO>:<TAG>
```
Example:
```bash
docker pull $REPO_FQDN/$REPO_NAME:$IMAGE_TAG
```

---

## 7. Listing & Inspecting Images

### 7.1 List image tags
Syntax:
```bash
aws ecr list-images --repository-name <REPO> --query 'imageIds[].imageTag'
```
Example:
```bash
aws ecr list-images --repository-name sample-api \
  --query 'imageIds[].{Tag:imageTag,Digest:imageDigest}'
```

### 7.2 Describe images (details)
Syntax:
```bash
aws ecr describe-images --repository-name <REPO>
```
Example (latest 5 by pushedAt):
```bash
aws ecr describe-images --repository-name sample-api \
  --query 'sort_by(imageDetails,&imagePushedAt)[-5:].[].{Tag: imageTags[0], Digest:imageDigest, SizeMB: imageSizeInBytes/1024/1024, Pushed: imagePushedAt}'
```

### 7.3 Get manifest (raw JSON)
```bash
aws ecr batch-get-image \
  --repository-name sample-api \
  --image-ids imageTag=$IMAGE_TAG \
  --query 'images[0].imageManifest' --output text | jq .
```

---

## 8. Image Scanning & Vulnerability Management

### 8.1 Start on-demand scan (enhanced or basic)
Syntax:
```bash
aws ecr start-image-scan --repository-name <REPO> --image-id imageTag=<TAG>
```
Example:
```bash
aws ecr start-image-scan --repository-name sample-api --image-id imageTag=$IMAGE_TAG
```

### 8.2 Get scan findings
Syntax:
```bash
aws ecr describe-image-scan-findings --repository-name <REPO> --image-id imageTag=<TAG>
```
Example (critical/high counts):
```bash
aws ecr describe-image-scan-findings \
  --repository-name sample-api \
  --image-id imageTag=$IMAGE_TAG \
  --query 'imageScanFindings.findingSeverityCounts.{CRITICAL:CRITICAL,HIGH:HIGH,MEDIUM:MEDIUM}'
```

### 8.3 Filter CVE IDs (top 5)
```bash
aws ecr describe-image-scan-findings \
  --repository-name sample-api \
  --image-id imageTag=$IMAGE_TAG \
  --query 'imageScanFindings.findings[?severity==`HIGH`].[name,uri]' \
  --output table | head -n 10
```

### 8.4 Set repository scanning configuration (enhanced) — (region dependent; may require subscription)
```bash
aws ecr put-registry-scanning-configuration \
  --scanning-configuration '{
    "scanType":"ENHANCED",
    "rules":[{"scanFrequency":"SCAN_ON_PUSH","repositoryFilters":[{"filter":"*","filterType":"WILDCARD"}]}]
  }'
```

---

## 9. Permissions & Repository Policies (Cross-Account)

### 9.1 Get repository policy
```bash
aws ecr get-repository-policy --repository-name sample-api
```

### 9.2 Put repository policy (allow other account read)
File: repo-policy.json
```json
{
  "Version":"2008-10-17",
  "Statement":[
    {
      "Sid":"AllowPullFromOtherAccount",
      "Effect":"Allow",
      "Principal":{"AWS":"arn:aws:iam::210987654321:root"},
      "Action":[
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer",
        "ecr:DescribeImages"
      ]
    }
  ]
}
```
Apply:
```bash
aws ecr set-repository-policy \
  --repository-name sample-api \
  --policy-text file://repo-policy.json
```

### 9.3 Grant push rights (add ecr:InitiateLayerUpload, ecr:PutImage, etc.)
Extend actions in policy statement.

---

## 10. Lifecycle Policies (Tag Retention / Expiration)

### 10.1 Sample lifecycle policy (keep 5 most recent semantic versions, expire untagged > 7 days)
File: lifecycle.json
```json
{
  "rules": [
    {
      "rulePriority": 10,
      "description": "Expire untagged images older than 7 days",
      "selection": {
        "tagStatus": "untagged",
        "countType": "sinceImagePushed",
        "countUnit": "days",
        "countNumber": 7
      },
      "action": { "type": "expire" }
    },
    {
      "rulePriority": 20,
      "description": "Keep last 5 versioned images (v*)",
      "selection": {
        "tagStatus": "tagged",
        "tagPrefixList": ["v"],
        "countType": "imageCountMoreThan",
        "countNumber": 5
      },
      "action": { "type": "expire" }
    }
  ]
}
```
Apply:
```bash
aws ecr put-lifecycle-policy \
  --repository-name sample-api \
  --lifecycle-policy-text file://lifecycle.json
```

### 10.2 Get lifecycle policy preview (optional)
```bash
aws ecr get-lifecycle-policy --repository-name sample-api
```

---

## 11. Replication Configuration (Cross-Region / Cross-Account)

### 11.1 Set replication to another region (same account)
File: replication.json
```json
{
  "rules": [
    {
      "destinations": [
        {
          "region": "us-west-2",
          "registryId": "123456789012"
        }
      ]
    }
  ]
}
```
Apply:
```bash
aws ecr put-replication-configuration \
  --replication-configuration file://replication.json
```

### 11.2 Multi-account replication (add destination with other registryId); ensure destination has permissions.

---

## 12. Batch Operations (Delete / Get)

### 12.1 Batch delete images by tag
Syntax:
```bash
aws ecr batch-delete-image --repository-name <REPO> --image-ids imageTag=<TAG1> imageTag=<TAG2>
```
Example:
```bash
aws ecr batch-delete-image \
  --repository-name sample-api \
  --image-ids imageTag=old1 imageTag=old2
```

### 12.2 Delete untagged images (script)
```bash
aws ecr list-images --repository-name sample-api --filter tagStatus=UNTAGGED \
  --query 'imageIds[].imageDigest' --output text | tr '\t' '\n' | \
while read D; do
  aws ecr batch-delete-image --repository-name sample-api --image-ids imageDigest=$D
done
```

### 12.3 Batch get images (manifests)
```bash
aws ecr batch-get-image \
  --repository-name sample-api \
  --image-ids imageTag=$IMAGE_TAG imageTag=$BASE_TAG \
  --query 'images[].{Tag:imageId.imageTag,Digest:imageId.imageDigest}'
```

---

## 13. Multi-Architecture Images (Buildx Manifest)

### 13.1 Build multi-arch (linux/amd64 + linux/arm64) with Docker Buildx
```bash
docker buildx create --use 2>/dev/null || true
docker buildx build \
  --platform linux/amd64,linux/arm64 \
  -t $REPO_FQDN/$REPO_NAME:multi-v1 \
  --push .
```

### 13.2 Inspect manifest
```bash
aws ecr batch-get-image \
  --repository-name sample-api \
  --image-ids imageTag=multi-v1 \
  --accepted-media-types application/vnd.docker.distribution.manifest.list.v2+json \
  --query 'images[0].imageManifest' --output text | jq .
```

---

## 14. Tagging Resources (Repository Tags vs Image Tags)

### 14.1 Tag repository (resource tagging)
```bash
REPO_ARN=$(aws ecr describe-repositories --repository-names sample-api --query 'repositories[0].repositoryArn' --output text)
aws ecr tag-resource --resource-arn $REPO_ARN --tags Key=Env,Value=dev Key=Service,Value=SampleApi
```

### 14.2 List repository tags
```bash
aws ecr list-tags-for-resource --resource-arn $REPO_ARN
```

### 14.3 Untag repository
```bash
aws ecr untag-resource --resource-arn $REPO_ARN --tag-keys Env
```

---

## 15. Cost & Optimization Tips
- Enable lifecycle policies to prune untagged / stale images.
- Avoid pushing large layers repeatedly; leverage multi-stage builds & caching.
- Consolidate base images; share common layers for faster pulls/deploys.
- Delete unused repositories to reduce management overhead (storage cost may persist until images removed).
- Use gzip & minimal images (distroless / alpine) to shrink transfer time.
- Replicate only required repositories; avoid wildcard replication if unnecessary.

---

## 16. Automation Snippets

### 16.1 Idempotent repository create
```bash
REPO_CHECK=$(aws ecr describe-repositories --repository-names $REPO_NAME 2>/dev/null || true)
if [ -z "$REPO_CHECK" ]; then
  aws ecr create-repository --repository-name $REPO_NAME \
    --image-scanning-configuration scanOnPush=true
fi
```

### 16.2 Promote image from dev to prod repo
```bash
DEV_REPO=sample-api
PROD_REPO=sample-api-prod
DIGEST=$(aws ecr list-images --repository-name $DEV_REPO \
  --filter tagStatus=TAGGED --query "imageIds[?imageTag=='$IMAGE_TAG'].imageDigest" --output text)
aws ecr batch-get-image --repository-name $DEV_REPO \
  --image-ids imageDigest=$DIGEST \
  --query 'images[0].imageManifest' --output text > manifest.json
aws ecr put-image --repository-name $PROD_REPO \
  --image-manifest file://manifest.json --image-tag $IMAGE_TAG
```

### 16.3 Fail build on critical vulnerabilities
```bash
SCAN=$(aws ecr describe-image-scan-findings --repository-name $REPO_NAME --image-id imageTag=$IMAGE_TAG \
  --query 'imageScanFindings.findingSeverityCounts.CRITICAL' --output text 2>/dev/null || echo 0)
[ "$SCAN" != "None" ] && [ "$SCAN" -gt 0 ] && echo "Critical vulns detected ($SCAN)" && exit 1
```

### 16.4 Bulk delete old tags (keep latest N)
```bash
KEEP=5
aws ecr describe-images --repository-name $REPO_NAME \
  --query 'sort_by(imageDetails,&imagePushedAt)[].imageTags[0]' --output text | tr '\t' '\n' | grep -v '^$' > /tmp/tags.txt
TOTAL=$(wc -l < /tmp/tags.txt)
if [ $TOTAL -gt $KEEP ]; then
  head -n $((TOTAL-KEEP)) /tmp/tags.txt | while read T; do
    aws ecr batch-delete-image --repository-name $REPO_NAME --image-ids imageTag=$T
  done
fi
```

---

## 17. Best Practices
- Immutable tags (set `image-tag-mutability=IMMUTABLE`) for deployment determinism—use new tag per build.
- Use semantic or commit SHA tagging (e.g., `1.2.3` + `sha-<short>`).
- Scan images early (pre-deploy) and block release on critical/high vulnerabilities with policy.
- Implement least-privilege repository policies: producers (push) vs consumers (pull).
- Regularly prune unreferenced & untagged layers via lifecycle policies.
- Prefer multi-stage builds to minimize final runtime image size.
- Use multi-arch builds only when needed (slightly more overhead).
- Replicate only compliance-critical or latency-sensitive repos across regions.
- Keep base images updated to reduce vulnerability counts.
- Store SBOM metadata externally or embed labels for supply chain tracking.

---

## 18. Troubleshooting
| Issue | Symptom | Likely Cause | Resolution |
|-------|---------|--------------|-----------|
| AccessDenied | Push/pull fails | Missing ecr:* IAM actions | Add `ecr:GetAuthorizationToken`, `BatchCheckLayerAvailability`, `PutImage`, `InitiateLayerUpload` |
| Unauthorized: auth required | Docker push error | Not logged in / token expired (12h) | Re-run get-login-password |
| ImageAlreadyExistsException | PutImage fails | Tag immutable & tag already used | Use a new tag or switch to MUTABLE (not recommended) |
| ManifestInvalidException | Push fails | Incorrect manifest or cross-arch mismatch | Ensure proper build & tag; avoid manual manifest edits |
| Scan findings empty | No vulnerabilities listed | Scan not completed yet / disabled | Wait; verify scanOnPush or start-image-scan |
| KMS AccessDenied | Repo creation with custom key fails | Principal lacks kms:Encrypt/Decrypt | Update KMS key policy for ECR service role and user |
| ThrottlingException | Rapid batch operations | API rate limit | Add exponential backoff; batch image IDs sensibly |
| Lifecycle policy not expiring images | Old images remain | Policy syntax or rule priority incorrect | Validate with `get-lifecycle-policy`; ensure matching tag filters |
| Cross-account pull denied | 403 pull | Repo policy missing actions | Add `ecr:BatchGetImage` & `ecr:GetDownloadUrlForLayer` for external principal |
| Multi-arch missing architecture | Deploy failure on arm64 | Manifest lacks arm64 entry | Rebuild using buildx with `--platform` list |

---

## 19. Cleanup Sequences

### 19.1 Delete all images in repository
```bash
aws ecr list-images --repository-name $REPO_NAME \
  --query 'imageIds' --output json > /tmp/imageids.json
if [ "$(jq 'length' /tmp/imageids.json)" -gt 0 ]; then
  aws ecr batch-delete-image --repository-name $REPO_NAME \
    --image-ids file:///tmp/imageids.json
fi
```

### 19.2 Remove lifecycle & replication (optional)
```bash
aws ecr delete-lifecycle-policy --repository-name $REPO_NAME 2>/dev/null || true
aws ecr put-replication-configuration --replication-configuration '{"rules":[]}'
```

### 19.3 Delete repository
```bash
aws ecr delete-repository --repository-name $REPO_NAME --force
```

### 19.4 Remove registry scanning config (reset to BASIC)
```bash
aws ecr put-registry-scanning-configuration --scanning-configuration '{"scanType":"BASIC"}'
```

---

## 20. Notes
- Image layer storage counts against ECR usage even if untagged (until garbage collected).
- Tag immutability prevents accidental overwrites; treat mutable tags cautiously (e.g., `latest`).
- Basic scanning uses open-source scanners; enhanced adds more coverage (regional support varies).
- Authorization tokens expire ~12 hours—re-auth in CI/CD before each push stage.
- CLI pagination: `describe-images` may need `--max-results` + `--next-token`.
- Cross-account replication may increase storage & data transfer cost—plan retention.
- For Lambda container images (ECR), size limit is currently 10 GB—optimize to reduce cold start.

---
